

options {
  NODE_DEFAULT_VOID = true;
  NODE_CLASS="ASTNode";
  NODE_PREFIX = "";
  MULTI=true;
  LOOKAHEAD=2;
  STATIC=true;
}

PARSER_BEGIN(ASTGentor)
package czlab.tecs.p11;

import java.util.ArrayList;
import java.util.List;

public class ASTGentor {

  public static SimpleNode parseOneUnit()
  throws Exception {
    return parseClazz();
  }

}

PARSER_END(ASTGentor)

SKIP :
{
  < " " >
  | < "\t" >
  | < "\n" >
  | < "\r" >
  | < "//" (~["\n"])* "\n" >
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/**********************************************
 * THE Jack TOKEN SPECIFICATION STARTS HERE *
 **********************************************/

TOKEN :
{
  < CLASS: "class" >
  | < CONSTRUCTOR: "constructor" >
  | < FUNCTION: "function" >
  | < METHOD: "method" >
  | < FIELD: "field" >
  | < STATIK: "static" >
  | < VAR: "var" >
  | < INT: "int" >
  | < CHAR: "char" >
  | < BOOLEAN: "boolean" >
  | < VOID: "void" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < NULL: "null" >
  | < THIS: "this" >
  | < LET: "let" >
  | < DO: "do" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < WHILE: "while" >
  | < RETURN: "return" >
  | < LCURLY: "{" >
  | < RCURLY: "}" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  | < LBRAC: "[" >
  | < RBRAC: "]" >
  | < DOT: "." >
  | < COMMA: "," >
  | < SEMICOLON: ";" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < STAR: "*" >
  | < SLASH: "/" >
  | < AND: "&" >
  | < BAR: "|" >
  | < LT: "<" >
  | < GT: ">" >
  | < EQ: "=" >
  | < TILDA: "~" >

}

TOKEN :
{
  < QSTRING: "\"" (~["\"", "\\"] | "\\\"" | "\\\\")* "\"" >
  |
  < NUMBER: "0" | ["1" - "9"] (["0" - "9"])* >
}

TOKEN :
{
  < IDENTIFIER: <ALPHA> (<ALPHA>|<DIGIT>)* >
  |
  < #ALPHA: "_" | ["a"-"z", "A"-"Z"]>
  |
  < #DIGIT: ["0"-"9"]>
}

TOKEN :
{
  < SCOPEDINVOKER: <IDENTIFIER> <DOT> <IDENTIFIER> >
}

/************************************************
 * THE Jack GRAMMAR SPECIFICATION STARTS HERE *
 ************************************************/
//kenl
ClassDec parseClazz() #ClassDec :
{Token z;}
{
  <CLASS> z=className() <LCURLY>
  (classVarDec())*
  (subroutineDec())*
  <RCURLY> {
    jjtThis.props.put("name", z.image);
    return jjtThis;
  }
}

//////////////////////////////////////////////////////////////////////////////
//
void classVarDec() #ClassVarDec :
{List<String> vs= new ArrayList<String>();
 Token v, t;
 String q="";}
{
  [<STATIK> {q=token.image;} |
   <FIELD> {q=token.image;}]
  t=type()
  v=varName()
  { vs.add(v.image); }
  (<COMMA> v=varName()
  { vs.add(v.image); })* <SEMICOLON> {
    jjtThis.props.put("qualifier", q);
    jjtThis.props.put("type", t.image);
    jjtThis.props.put("vars", vs);
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token type() :
{}
{
  <INT>  { return token;} |
  <CHAR>  { return token;} |
  <BOOLEAN> { return token;} |
  //classNAme()
  <IDENTIFIER> { return token;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void subroutineDec() #SubroutineDec :
{String r="", q="";
 Object vs=null; 
 Object pml=null;
 Token sn,t;}
{
  [<CONSTRUCTOR> {q=token.image;} |
   <FUNCTION> {q=token.image;} |
   <METHOD> {q=token.image;}]
  [<VOID> {r=token.image;} |
   t=type() {r=t.image;}]
  sn=subroutineName()
  <LPAREN>
  pml=parameterList()
  <RPAREN>
  <LCURLY> (vs=varDec())* statements() <RCURLY> {
    jjtThis.props.put("qualifier", q);
    jjtThis.props.put("type", r);
    jjtThis.props.put("name", sn);
    if (pml != null) {
      jjtThis.props.put("args", pml);
    }
    if (vs != null) {
      jjtThis.props.put("vars", vs);
    }
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Object parameterList() :
{List<String> ps= new ArrayList<String>();
 Token vn, t;}
{
  ((t=type() vn=varName() {
    ps.add(t.image); ps.add(vn.image);
    })
   (<COMMA> t=type() vn=varName() {
    ps.add(t.image); ps.add(vn.image);
    })*)? {
    return ps;
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Object varDec() :
{List<String> ps=new ArrayList<String>();
Token vn, t;}
{
  <VAR> t=type() vn=varName() {
    ps.add(t.image); ps.add(vn.image);
  }
  (<COMMA> vn=varName() {
    ps.add(t.image); ps.add(vn.image);
   })* <SEMICOLON> {
    return ps;
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void statements() #Statements :
{}
{
  (statement())*
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void statement() :
{}
{
  letStatement()  |
  ifStatement()  |
  whileStatement()  |
  doStatement()  |
  returnStatement()
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void letStatement() #LetStatement :
{Token vn;}
{
  <LET> vn=varName()
  (<LBRAC> expr() <RBRAC>)?
  <EQ> expr() <SEMICOLON> {
    jjtThis.props.put("var", vn.image);
    int cnt= jjtThis.jjtGetNumChildren();
    if (cnt == 2) {
      jjtThis.nested.put("lhs", jjtThis.jjtGetChild(0));
      jjtThis.nested.put("rhs", jjtThis.jjtGetChild(1));
    } else {
      jjtThis.nested.put("rhs", jjtThis.jjtGetChild(0));
    }
    jjtThis.removeChildren();
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void ifStatement() #IfStatement :
{}
{
  <IF> <LPAREN> expr() <RPAREN>
  <LCURLY> statements() <RCURLY> #IfBlock(1)
  (<ELSE> <LCURLY> statements() <RCURLY> #ElseBlock(1))? {
    jjtThis.nested.put("test", jjtThis.popChild());
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void whileStatement() #WhileStatement :
{}
{
  <WHILE> <LPAREN> expr() <RPAREN>
    <LCURLY> statements() <RCURLY> #WhileBlock(1) {
    jjtThis.nested.put("test", jjtThis.popChild());
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void doStatement() #DoStatement :
{}
{
  <DO> subroutineCall() <SEMICOLON>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void returnStatement() #ReturnStatement :
{}
{
  <RETURN> <SEMICOLON> |
  <RETURN> expr() <SEMICOLON> {
    jjtThis.nested.put("value", jjtThis.popChild());
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void expr() #Expression :
{}
{
  term() (op() term())*
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void term() #Term :
{Object e=null;
 Token vn;}
{
  <LPAREN> expr() <RPAREN> {
  } |
  unaryOp() term() |
  integerConstant() |
  stringConstant()  |
  keywordConstant()  |
  subroutineCall() |
  vn=varName() <LBRAC> expr() <RBRAC>  {
    jjtThis.props.put("var", vn.image);
  } | vn=varName() {
    jjtThis.props.put("var", vn.image);
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void subroutineCall() #SubroutineCall :
{Token sn;}
{
  sn=subroutineName()
    <LPAREN> exprList() <RPAREN> {
    jjtThis.props.put("subroutine", sn.image);
  } |
  sn=scopedCall()
  <LPAREN> exprList() <RPAREN> {
    jjtThis.props.put("subroutine", sn.image);
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void exprList() #ExpressionList :
{}
{
  (expr() (<COMMA> expr() )*)? {
    jjtThis.nested.put("elist", jjtThis.popAll());
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token scopedCall() :
{}
{
  <SCOPEDINVOKER> {
    //System.out.println("scopedinvoker= " + t.image);
    //return t.image.split("\\.");
    return token;
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void op() #Operation :
{}
{
  <PLUS> {jjtThis.value=token.image;} |
  <MINUS> {jjtThis.value=token.image;} |
  <STAR> {jjtThis.value=token.image;} |
  <SLASH> {jjtThis.value=token.image;} |
  <AND> {jjtThis.value=token.image;} |
  <BAR> {jjtThis.value=token.image;} |
  <LT> {jjtThis.value=token.image;} |
  <GT> {jjtThis.value=token.image;} |
  <EQ> {jjtThis.value=token.image;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void unaryOp() #UnaryOperation :
{}
{
  <MINUS> {jjtThis.value=token.image;} |
  <TILDA> {jjtThis.value=token.image;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void integerConstant() #IntegerConstant :
{}
{ <NUMBER> {jjtThis.value=token.image;} }

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void stringConstant() #StringConstant :
{String s;}
{
  <QSTRING> {
    s=token.image;
    jjtThis.value=s.substring(1,s.length()-1);
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void keywordConstant() #Keyword :
{}
{
  <TRUE> {jjtThis.value=token.image;} |
  <FALSE> {jjtThis.value=token.image;} |
  <NULL> {jjtThis.value=token.image;} |
  <THIS> {jjtThis.value=token.image;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token subroutineName() :
{}
{
  <IDENTIFIER> { return token;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token className() :
{}
{
  <IDENTIFIER> {return token;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token varName() :
{}
{
  <IDENTIFIER> { return token;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//EOF



