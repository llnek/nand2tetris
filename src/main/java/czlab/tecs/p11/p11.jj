/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. p11.jj */
/*@egen*/

options {
                           
                       
                   
             
  LOOKAHEAD=2;
  STATIC=true;
}

PARSER_BEGIN(ASTGentor)
package czlab.tecs.p11;

import java.util.ArrayList;
import java.util.List;

public class ASTGentor/*@bgen(jjtree)*/implements ASTGentorTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTASTGentorState jjtree = new JJTASTGentorState();

/*@egen*/

  public static SimpleNode parseOneUnit()
  throws Exception {
    return parseClazz();
  }

}

PARSER_END(ASTGentor)

SKIP :
{
  < " " >
  | < "\t" >
  | < "\n" >
  | < "\r" >
  | < "//" (~["\n"])* "\n" >
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/**********************************************
 * THE Jack TOKEN SPECIFICATION STARTS HERE *
 **********************************************/

TOKEN :
{
  < CLASS: "class" >
  | < CONSTRUCTOR: "constructor" >
  | < FUNCTION: "function" >
  | < METHOD: "method" >
  | < FIELD: "field" >
  | < STATIK: "static" >
  | < VAR: "var" >
  | < INT: "int" >
  | < CHAR: "char" >
  | < BOOLEAN: "boolean" >
  | < VOID: "void" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < NULL: "null" >
  | < THIS: "this" >
  | < LET: "let" >
  | < DO: "do" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < WHILE: "while" >
  | < RETURN: "return" >
  | < LCURLY: "{" >
  | < RCURLY: "}" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  | < LBRAC: "[" >
  | < RBRAC: "]" >
  | < DOT: "." >
  | < COMMA: "," >
  | < SEMICOLON: ";" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < STAR: "*" >
  | < SLASH: "/" >
  | < AND: "&" >
  | < BAR: "|" >
  | < LT: "<" >
  | < GT: ">" >
  | < EQ: "=" >
  | < TILDA: "~" >

}

TOKEN :
{
  < QSTRING: "\"" (~["\"", "\\"] | "\\\"" | "\\\\")* "\"" >
  |
  < NUMBER: "0" | ["1" - "9"] (["0" - "9"])* >
}

TOKEN :
{
  < IDENTIFIER: <ALPHA> (<ALPHA>|<DIGIT>)* >
  |
  < #ALPHA: "_" | ["a"-"z", "A"-"Z"]>
  |
  < #DIGIT: ["0"-"9"]>
}

TOKEN :
{
  < SCOPEDINVOKER: <IDENTIFIER> <DOT> <IDENTIFIER> >
}

/************************************************
 * THE Jack GRAMMAR SPECIFICATION STARTS HERE *
 ************************************************/
//kenl
ClassDec parseClazz()           :
{/*@bgen(jjtree) ClassDec */
 ClassDec jjtn000 = new ClassDec(JJTCLASSDEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token z;}
{/*@bgen(jjtree) ClassDec */
  try {
/*@egen*/
  <CLASS> z=className() <LCURLY>
  (classVarDec())*
  (subroutineDec())*
  <RCURLY>/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {
    jjtn000.props.put("name", z.image);
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//////////////////////////////////////////////////////////////////////////////
//
void classVarDec()              :
{/*@bgen(jjtree) ClassVarDec */
 ClassVarDec jjtn000 = new ClassVarDec(JJTCLASSVARDEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/List<String> vs= new ArrayList<String>();
 Token v, t;
 String q="";}
{/*@bgen(jjtree) ClassVarDec */
  try {
/*@egen*/
  [<STATIK> {q=token.image;} |
   <FIELD> {q=token.image;}]
  t=type()
  v=varName()
  { vs.add(v.image); }
  (<COMMA> v=varName()
  { vs.add(v.image); })* <SEMICOLON>/*@bgen(jjtree)*/
                                     {
                                       jjtree.closeNodeScope(jjtn000, true);
                                       jjtc000 = false;
                                     }
/*@egen*/ {
    jjtn000.props.put("qualifier", q);
    jjtn000.props.put("type", t.image);
    jjtn000.props.put("vars", vs);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token type() :
{}
{
  <INT>  { return token;} |
  <CHAR>  { return token;} |
  <BOOLEAN> { return token;} |
  //classNAme()
  <IDENTIFIER> { return token;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void subroutineDec()                :
{/*@bgen(jjtree) SubroutineDec */
 SubroutineDec jjtn000 = new SubroutineDec(JJTSUBROUTINEDEC);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/String r="", q="";
 Object vs=null;
 Object pml=null;
 ASTNode ss;
 Token sn,t;}
{/*@bgen(jjtree) SubroutineDec */
  try {
/*@egen*/
  [<CONSTRUCTOR> {q=token.image;} |
   <FUNCTION> {q=token.image;} |
   <METHOD> {q=token.image;}]
  [<VOID> {r=token.image;} |
   t=type() {r=t.image;}]
  sn=subroutineName()
  <LPAREN>
  pml=parameterList()
  <RPAREN>
  <LCURLY> (vs=varDec())* statements() <RCURLY>/*@bgen(jjtree)*/
                                                {
                                                  jjtree.closeNodeScope(jjtn000, true);
                                                  jjtc000 = false;
                                                }
/*@egen*/ {
    jjtn000.props.put("qualifier", q);
    jjtn000.props.put("type", r);
    jjtn000.props.put("name", sn);
    if (pml != null) {
      jjtn000.props.put("args", pml);
    }
    if (vs != null) {
      jjtn000.props.put("vars", vs);
    }
    ss=(ASTNode)jjtn000.popChild();
    jjtn000.nested.put("statements",ss.popAll());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Object parameterList() :
{List<String> ps= new ArrayList<String>();
 Token vn, t;}
{
  ((t=type() vn=varName() {
    ps.add(t.image); ps.add(vn.image);
    })
   (<COMMA> t=type() vn=varName() {
    ps.add(t.image); ps.add(vn.image);
    })*)? {
    return ps;
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Object varDec() :
{List<String> ps=new ArrayList<String>();
Token vn, t;}
{
  <VAR> t=type() vn=varName() {
    ps.add(t.image); ps.add(vn.image);
  }
  (<COMMA> vn=varName() {
    ps.add(t.image); ps.add(vn.image);
   })* <SEMICOLON> {
    return ps;
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void statements()             :
{/*@bgen(jjtree) Statements */
  Statements jjtn000 = new Statements(JJTSTATEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statements */
  try {
/*@egen*/
  (statement())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void statement() :
{}
{
  letStatement()  |
  ifStatement()  |
  whileStatement()  |
  doStatement()  |
  returnStatement()
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void letStatement()               :
{/*@bgen(jjtree) LetStatement */
 LetStatement jjtn000 = new LetStatement(JJTLETSTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token vn;}
{/*@bgen(jjtree) LetStatement */
  try {
/*@egen*/
  <LET> vn=varName()
  (<LBRAC> expr() <RBRAC>)?
  <EQ> expr() <SEMICOLON>/*@bgen(jjtree)*/
                          {
                            jjtree.closeNodeScope(jjtn000, true);
                            jjtc000 = false;
                          }
/*@egen*/ {
    jjtn000.props.put("varr", vn.image);
    int cnt= jjtn000.jjtGetNumChildren();
    if (cnt == 2) {
      jjtn000.nested.put("lhs", jjtn000.jjtGetChild(0));
      jjtn000.nested.put("rhs", jjtn000.jjtGetChild(1));
    } else {
      jjtn000.nested.put("rhs", jjtn000.jjtGetChild(0));
    }
    jjtn000.removeChildren();
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void ifStatement()              :
{/*@bgen(jjtree) IfStatement */
 IfStatement jjtn000 = new IfStatement(JJTIFSTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/ASTNode n;}
{/*@bgen(jjtree) IfStatement */
  try {
/*@egen*/
  <IF> <LPAREN> expr() <RPAREN>
  <LCURLY> statements()/*@bgen(jjtree) #IfBlock( 1) */
                        {
                          IfBlock jjtn001 = new IfBlock(JJTIFBLOCK);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ <RCURLY>/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  1);
                          }
                        }
/*@egen*/            
  (<ELSE> <LCURLY> statements()/*@bgen(jjtree) #ElseBlock( 1) */
                                {
                                  ElseBlock jjtn002 = new ElseBlock(JJTELSEBLOCK);
                                  boolean jjtc002 = true;
                                  jjtree.openNodeScope(jjtn002);
                                }
                                try {
/*@egen*/ <RCURLY>/*@bgen(jjtree)*/
                                } finally {
                                  if (jjtc002) {
                                    jjtree.closeNodeScope(jjtn002,  1);
                                  }
                                }
/*@egen*/              )?/*@bgen(jjtree)*/
                                                         {
                                                           jjtree.closeNodeScope(jjtn000, true);
                                                           jjtc000 = false;
                                                         }
/*@egen*/ {
    jjtn000.nested.put("test", jjtn000.popChild());
    n= (ASTNode)jjtn000.popChild(); //if
    jjtn000.nested.put("if", n.popChild().popAll());
    n= (ASTNode)jjtn000.popChild(); //else?
    if (n != null) {
      jjtn000.nested.put("else", n.popChild().popAll());
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void whileStatement()                 :
{/*@bgen(jjtree) WhileStatement */
  WhileStatement jjtn000 = new WhileStatement(JJTWHILESTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WhileStatement */
  try {
/*@egen*/
  <WHILE> <LPAREN> expr() <RPAREN>
    <LCURLY> statements()/*@bgen(jjtree) #WhileBlock( 1) */
                          {
                            WhileBlock jjtn001 = new WhileBlock(JJTWHILEBLOCK);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
                          }
                          try {
/*@egen*/ <RCURLY>/*@bgen(jjtree)*/
                          } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  1);
                            }
                          }
/*@egen*/               /*@bgen(jjtree)*/
                                                  {
                                                    jjtree.closeNodeScope(jjtn000, true);
                                                    jjtc000 = false;
                                                  }
/*@egen*/ {
    jjtn000.nested.put("test", jjtn000.popChild());
    jjtn000.nested.put("body", jjtn000.popChild().popChild().popAll());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void doStatement()              :
{/*@bgen(jjtree) DoStatement */
  DoStatement jjtn000 = new DoStatement(JJTDOSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DoStatement */
  try {
/*@egen*/
  <DO> subroutineCall() <SEMICOLON>/*@bgen(jjtree)*/
                                    {
                                      jjtree.closeNodeScope(jjtn000, true);
                                      jjtc000 = false;
                                    }
/*@egen*/ {
    jjtn000.nested.put("call", jjtn000.popChild());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void returnStatement()                  :
{/*@bgen(jjtree) ReturnStatement */
  ReturnStatement jjtn000 = new ReturnStatement(JJTRETURNSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ReturnStatement */
  try {
/*@egen*/
  <RETURN> <SEMICOLON> |
  <RETURN> expr() <SEMICOLON>/*@bgen(jjtree)*/
                              {
                                jjtree.closeNodeScope(jjtn000, true);
                                jjtc000 = false;
                              }
/*@egen*/ {
    jjtn000.nested.put("value", jjtn000.popChild());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void expr()             :
{/*@bgen(jjtree) Expression */
  Expression jjtn000 = new Expression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
  try {
/*@egen*/
  term() (op() term())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void term()       :
{/*@bgen(jjtree) Term */
 Term jjtn000 = new Term(JJTTERM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Object e=null;
 String s;
 Token t, vn;}
{/*@bgen(jjtree) Term */
  try {
/*@egen*/
  <LPAREN> expr() <RPAREN>/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ {
    jjtn000.nested.put("group", jjtn000.popChild());
  } |
  t=unaryOp() term()/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {
    jjtn000.nested.put("unary", t.image);
    jjtn000.nested.put("term", jjtn000.popChild());
  } |
  t= integerConstant()/*@bgen(jjtree)*/
                       {
                         jjtree.closeNodeScope(jjtn000, true);
                         jjtc000 = false;
                       }
/*@egen*/ {
    jjtn000.nested.put("literal", "int");
    jjtn000.value=t.image;
  } |
  s=stringConstant()/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/ {
    jjtn000.nested.put("literal", "String");
    jjtn000.value=s;
  }  |
  t=keywordConstant()/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ {
    jjtn000.nested.put("literal", "keyword");
    jjtn000.value=t.image;
  } |
  subroutineCall() |
  vn=varName() <LBRAC> expr() <RBRAC>/*@bgen(jjtree)*/
                                       {
                                         jjtree.closeNodeScope(jjtn000, true);
                                         jjtc000 = false;
                                       }
/*@egen*/  {
    jjtn000.nested.put("index", jjtn000.popChild());
    jjtn000.nested.put("varr", vn.image);
  } | vn=varName()/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                   }
/*@egen*/ {
    jjtn000.nested.put("varr", vn.image);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void subroutineCall()                 :
{/*@bgen(jjtree) SubroutineCall */
 SubroutineCall jjtn000 = new SubroutineCall(JJTSUBROUTINECALL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/Token sn;}
{/*@bgen(jjtree) SubroutineCall */
  try {
/*@egen*/
  sn=subroutineName()
    <LPAREN> exprList() <RPAREN>/*@bgen(jjtree)*/
                                 {
                                   jjtree.closeNodeScope(jjtn000, true);
                                   jjtc000 = false;
                                 }
/*@egen*/ {
    jjtn000.nested.put("target", sn.image);
    jjtn000.nested.put("params", jjtn000.popChild().popAll());
  } |
  sn=scopedCall()
  <LPAREN> exprList() <RPAREN>/*@bgen(jjtree)*/
                               {
                                 jjtree.closeNodeScope(jjtn000, true);
                                 jjtc000 = false;
                               }
/*@egen*/ {
    jjtn000.nested.put("target", sn.image);
    jjtn000.nested.put("params", jjtn000.popChild().popAll());
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void exprList()                 :
{/*@bgen(jjtree) ExpressionList */
  ExpressionList jjtn000 = new ExpressionList(JJTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ExpressionList */
  try {
/*@egen*/
  (expr() (<COMMA> expr() )*)?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token scopedCall() :
{}
{
  <SCOPEDINVOKER> {
    //System.out.println("scopedinvoker= " + t.image);
    //return t.image.split("\\.");
    return token;
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void op()     :
{/*@bgen(jjtree) OP */
  OP jjtn000 = new OP(JJTOP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) OP */
  try {
/*@egen*/
  //precedence top to bottom
  <BAR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ {
    jjtn000.nested.put("bind", "left");
    jjtn000.nested.put("rank", 13);
    jjtn000.value=token.image;} |
  <AND>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/ {
    jjtn000.nested.put("bind", "left");
    jjtn000.nested.put("rank", 12);
    jjtn000.value=token.image;} |
  <EQ>/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
       }
/*@egen*/ {
    jjtn000.nested.put("bind", "left");
    jjtn000.nested.put("rank", 8);
    jjtn000.value=token.image;} |
  <LT>/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
       }
/*@egen*/ {
    jjtn000.nested.put("bind", "left");
    jjtn000.nested.put("rank", 7);
    jjtn000.value=token.image;} |
  <GT>/*@bgen(jjtree)*/
       {
         jjtree.closeNodeScope(jjtn000, true);
         jjtc000 = false;
       }
/*@egen*/ {
    jjtn000.nested.put("bind", "left");
    jjtn000.nested.put("rank", 7);
    jjtn000.value=token.image;} |
  <STAR>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/ {
    jjtn000.nested.put("bind", "left");
    jjtn000.nested.put("rank", 4);
    jjtn000.value=token.image;} |
  <SLASH>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {
    jjtn000.nested.put("bind", "left");
    jjtn000.nested.put("rank", 4);
    jjtn000.value=token.image;} |
  <PLUS>/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/ {
    jjtn000.nested.put("bind", "right");
    jjtn000.nested.put("rank", 2);
    jjtn000.value=token.image;} |
  <MINUS>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/ {
    jjtn000.nested.put("bind", "right");
    jjtn000.nested.put("rank", 2);
    jjtn000.value=token.image;}/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token unaryOp() :
{}
{
  <MINUS> {return token;} |
  <TILDA> {return token;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token integerConstant() :
{}
{ <NUMBER> { return token;} }

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
String stringConstant() :
{String s;}
{
  <QSTRING> {
    s=token.image;
    return s.substring(1,s.length()-1);
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token keywordConstant() :
{}
{
  <TRUE> { return token; } |
  <FALSE> { return token; } |
  <NULL> { return token; } |
  <THIS> { return token; }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token subroutineName() :
{}
{
  <IDENTIFIER> { return token;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token className() :
{}
{
  <IDENTIFIER> {return token;}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
Token varName() :
{}
{
  <IDENTIFIER> { return token;}
}