

options {
  NODE_DEFAULT_VOID = true;
  NODE_PREFIX = "";
  MULTI=true;
  //FORCE_LA_CHECK=true;
  LOOKAHEAD=2;
  STATIC=false;
}

PARSER_BEGIN(ASTGentor)
package czlab.tecs.ast;

public class ASTGentor {

  public SimpleNode parseOneUnit() throws Exception {
    return this.parseClazz();
  }

}

PARSER_END(ASTGentor)

SKIP :
{
  < " " >
  | < "\t" >
  | < "\n" >
  | < "\r" >
  | < "//" (~["\n"])* "\n" >
  | <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


/**********************************************
 * THE Jack TOKEN SPECIFICATION STARTS HERE *
 **********************************************/

TOKEN :
{
  < CLASS: "class" >
  | < CONSTRUCTOR: "constructor" >
  | < FUNCTION: "function" >
  | < METHOD: "method" >
  | < FIELD: "field" >
  | < STATIK: "static" >
  | < VAR: "var" >
  | < INT: "int" >
  | < CHAR: "char" >
  | < BOOLEAN: "boolean" >
  | < VOID: "void" >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < NULL: "null" >
  | < THIS: "this" >
  | < LET: "let" >
  | < DO: "do" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < WHILE: "while" >
  | < RETURN: "return" >
  | < LCURLY: "{" >
  | < RCURLY: "}" >
  | < LPAREN: "(" >
  | < RPAREN: ")" >
  | < LBRAC: "[" >
  | < RBRAC: "]" >
  | < DOT: "." >
  | < COMMA: "," >
  | < SEMICOLON: ";" >
  | < PLUS: "+" >
  | < MINUS: "-" >
  | < STAR: "*" >
  | < SLASH: "/" >
  | < AND: "&" >
  | < BAR: "|" >
  | < LT: "<" >
  | < GT: ">" >
  | < EQ: "=" >
  | < TILDA: "~" >

}

TOKEN :
{
  < QSTRING: "\"" (~["\"", "\\"] | "\\\"" | "\\\\")* "\"" >
  |
  < NUMBER: "0" | ["1" - "9"] (["0" - "9"])* >
}

TOKEN :
{
  < IDENTIFIER: <ALPHA> (<ALPHA>|<DIGIT>)* >
  |
  < #ALPHA: "_" | ["a"-"z", "A"-"Z"]>
  |
  < #DIGIT: ["0"-"9"]>
}

TOKEN :
{
  < SCOPEDINVOKER: <IDENTIFIER> <DOT> <IDENTIFIER> >
}

/************************************************
 * THE Jack GRAMMAR SPECIFICATION STARTS HERE *
 ************************************************/
//kenl
void parseClazz() :
{ Token t; }
{
  <CLASS> className() <LCURLY>
  classVarDec()*
  subroutineDec()*
  <RCURLY>
}

//////////////////////////////////////////////////////////////////////////////
//
void classVarDec() :
{ Token t; }
{
  [<STATIK> | <FIELD>]
  type()
  varName()
  [<COMMA> varName()]* <SEMICOLON>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void type() :
{ Token t; }
{
  <INT>  |
  <CHAR>  |
  <BOOLEAN>  | classNAme()
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void subroutineDec() :
{ Token t; }
{
  [<CONSTRUCTOR> | <FUNCTION> | <METHOD>]
  [<VOID> | type()]
  subroutineName()
  <LPAREN>
  parameterList()
  <RPAREN>
  subroutineBody()
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void parameterList() :
{ Token t; }
{
  ([type() varName()]
   [<COMMA> type() varName()]*)?
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void subroutineBody() :
{ Token t; }
{
  <LCURLY> varDec()* statements() <RCURLY>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void varDec() :
{ Token t; }
{
  <VAR> type() varNAme() [<COMMA> varName()]* <SEMICOLON>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void statements() :
{}
{
  [statement()]*
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void statement() :
{}
{
  letStatement()  |
  ifStatement()  |
  whileStatement()  |
  doStatement()  |
  returnStatement()
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void letStatement() :
{ Token t; }
{
  <LET> varName() [<LBRAC> expr() <RBRAC>]?
  <EQ> expr() <SEMICOLON>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void ifStatement() :
{ Token t; }
{
  <IF> <LPAREN> expr() <RPAREN>
  <LCURLY> statements() <RCURLY>
  [<ELSE> <LCURLY> statements() <RCURLY>]?
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void whileStatement() :
{ Token t; }
{
  <WHILE> <LPAREN> expr() <RPAREN>
  <LCURLY> statements() <RCURLY>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void doStatement() :
{ Token t; }
{
  <DO> subroutineCall() <SEMICOLON>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void returnStatement() :
{ Token t; }
{
  <RETURN> <SEMICOLON>  |
  <RETURN> expr() <SEMICOLON>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void expr() :
{ Token t; }
{
  term() [op() term()]*
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void term() :
{ Token t; }
{
  <LPAREN> expr() <RPAREN>  |
  unaryOp() term() |
  integerConstant() |
  stringConstant()  |
  keywordConstant()  |
  subroutineCall() |
  varName() <LBRAC> expr() <RBRAC>  | varName()
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void subroutineCall() :
{ Token t; }
{
  subroutineName() <LPAREN> exprList() <RPAREN> |
  scopedCall() <LPAREN> exprList() <RPAREN>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void exprList() :
{ Token t; }
{
  (expr() [<COMMA> {} expr()]*)?
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void scopedCall() :
{ Token t; }
{
  <SCOPEDINVOKER> {
    //System.out.println("scopedinvoker= " + t.image);
    //return t.image.split("\\.");
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void op() :
{ Token t; }
{
  <PLUS> {} |
  <MINUS> {} |
  <STAR> {} |
  <SLASH> {} |
  <AND> {} |
  <BAR> {} |
  <LT> {} |
  <GT> {} |
  <EQ> {}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void unaryOp() :
{ Token t; }
{
  <MINUS> {} |
  <TILDA> {}
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void integerConstant() :
{ Token t; }
{ <NUMBER> { } }

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void stringConstant() :
{ String s; Token t; }
{
  <QSTRING> {
  }
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//
void keywordConstant() :
{ Token t; }
{
  <TRUE> {} |
  <FALSE> {} |
  <NULL> {} |
  <THIS> {}
}

void subroutineName() :
{}
{
  <IDENTIFIER>
}

void className() :
{}
{
  <IDENTIFIER>
}

void varName() :
{}
{
  <IDENTIFIER>
}

//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
//EOF


